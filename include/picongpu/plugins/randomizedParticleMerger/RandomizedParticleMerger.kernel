/* Copyright 2017-2020 Heiko Burau, Xeinia Bastrakova
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "picongpu/plugins/randomizedParticleMerger/VoronoiCell.hpp"
#include "picongpu/particles/access/Cell2Particle.hpp"
#include "picongpu/particles/filter/filter.hpp"

#include <pmacc/memory/Array.hpp>
#include <pmacc/memory/IndexPool.hpp>

namespace picongpu
{
namespace plugins
{
namespace randomizedParticleMerger
{

    using namespace pmacc::random::distributions;
    using Distribution = Uniform<float>;
    using RngFactory = particles::functor::misc::Rng< Distribution >;
    using RandomGen = RngFactory::RandomGen;

    /** Implements a particle merging algorithm based on
     *
     * Luu, P. T., Tueckmantel, T., & Pukhov, A. (2016).
     * Voronoi particle merging algorithm for PIC codes.
     * Computer Physics Communications, 202, 165-174.
     *
     * \tparam T_ParticlesBox container of the particle species
     */
    template< class T_ParticlesBox >
    struct RandomizedParticleMergerKernel
    {
        using ParticlesBox = T_ParticlesBox;
        using FramePtr = typename ParticlesBox::FramePtr;
        using FrameType = typename ParticlesBox::FrameType;
        using ArrayVoronoiCells = memory::Array<
            VoronoiCell,
            picongpu::plugins::particleMerging::MAX_VORONOI_CELLS // necessary for future particle merging
        >;
        using VoronoiIndexPool = memory::IndexPool<
            voronoiCellId::type,
            picongpu::plugins::particleMerging::MAX_VORONOI_CELLS // necessary for future particle merging
        >;


        ParticlesBox particlesBox;
        /** minimal number of macroparticles needed to divide
            the macroparticle collection  */
        uint32_t minMacroParticlesToDivide;
        /** Below this threshold of spread in position (squared) macroparticles
            can be merged [unit: cell edge length] */

        pmacc::math::Int<simDim> guardSuperCells;
        /** estimated fraction of macroparticles
            remaining after the merging process  */
        float_X ratioLeftParticles;
        /** min position threshold for
            macroparticles to be merged */
        float_X posSpreadThreshold;
        /** min momentum threshold for
            macroparticles to be merged */
        float_X momSpreadThreshold;
        /** factory of gitting random value */
        RngFactory rngFactory;

        RandomizedParticleMergerKernel(
            ParticlesBox particlesBox,
            uint32_t minMacroParticlesToDivide,
            float_X ratioDeletedParticles,
            float_X posSpreadThreshold,
            float_X momSpreadThreshold,
            RngFactory rngFactory,
            const pmacc::math::Int<simDim> guardSuperCells
        ) :
            particlesBox( particlesBox ),
            minMacroParticlesToDivide( minMacroParticlesToDivide ),
            ratioLeftParticles ( 1.0 - ratioDeletedParticles ),
            posSpreadThreshold ( posSpreadThreshold ),
            momSpreadThreshold ( momSpreadThreshold ),
            rngFactory ( rngFactory ),
            guardSuperCells ( guardSuperCells )
        {}

        /** map cell index to the initial Voronoi cell by aggregating N^simDim 'normal'
         * cells to a single Voronoi cell.
         *
         * @param cellIdx cell index
         */
        DINLINE voronoiCellId::type mapCellIdxToInitialVoronoiCell( const uint32_t cellIdx ) const
        {
            const DataSpace< simDim > cellIdxDim = DataSpaceOperations< simDim >::template map<
                SuperCellSize
            >( cellIdx );

            const DataSpace< simDim > voronoiCellDim = cellIdxDim / 2;

            return static_cast< voronoiCellId::type >(
                pmacc::math::linearize(
                    pmacc::math::CT::shrinkTo< SuperCellSize, simDim - 1 >::type::toRT() / 2,
                    voronoiCellDim
                )
            );
        }

        /** init the Voronoi cell id attribute for each particle in the super cell.
         *
         * The initial Voronoi cell is chosen by aggregating N^simDim 'normal' cells
         * to a single Voronoi cell.
         *
         * @param cellIdx cell index
         */
        template< typename T_Acc >
        DINLINE void initVoronoiCellIdAttribute(
            T_Acc const & acc,
            const pmacc::math::Int<simDim>& cellIdx
        )
        {
            //! \todo change this as soon as the kernel support lock step programming
            constexpr uint32_t numWorkers = pmacc::math::CT::volume< SuperCellSize >::type::value;
            const uint32_t workerIdx = DataSpaceOperations< simDim >::template map<
                SuperCellSize
            >( cellIdx % SuperCellSize::toRT() );
            particleAccess::Cell2Particle< SuperCellSize, numWorkers > forEachFrame;
            forEachFrame(
                acc,
                this->particlesBox,
                workerIdx,
                cellIdx,
                [this]( const T_Acc & acc, FramePtr frame, const int linearThreadIdx )
                {
                    auto particle = frame[linearThreadIdx];
                    const lcellId_t particleCellIdx = particle[localCellIdx_];
                    particle[voronoiCellId_] = this->mapCellIdxToInitialVoronoiCell( particleCellIdx );
                },
                particles::filter::All{}
            );
        }

        /** calculate position of particle within a super cell.
         *
         * @param particleCellIdx local particle cell index
         * @param positionWithinCell position within cell
         * @return position of particle with respect to its super cell's origin
         */
        DINLINE floatD_X getParticlePosWithinSuperCell(
            const lcellId_t particleCellIdx,
            const floatD_X positionWithinCell
        ) const
        {
            const DataSpace< simDim > particleCellIdxDim = DataSpaceOperations< simDim >::template map<
                SuperCellSize
            >( particleCellIdx );

            floatD_X result;
            for( int i = 0; i < simDim; i++ )
            {
                result[i] = static_cast< float_X >( particleCellIdxDim[i] ) + positionWithinCell[i];
            }

            return result;
        }

        /** calculate revative position of partilce in Supercell
         *
         * @param absoluteParticlePos absolute particle coordinates
         * @return particleCellIdx particle's supercell
         * @return positionWithinCell position particle inside supecell
         */

        DINLINE void getSuperCellPos(
            const floatD_X absoluteParticlePos,
            ::pmacc::math::Vector<int, simDim>& particleCellIdx,
            floatD_X& positionWithinCell
        )
        {
            for( int i = 0; i < simDim; i++ )
            {
                particleCellIdx[i] = static_cast<int>( absoluteParticlePos[i] );
                positionWithinCell[i] = absoluteParticlePos[i] - particleCellIdx[i];
            }
        }

        /** Decide if subdivision should be done, based on
         * information from parents voronoi cells
         *
         * @param randomGen ramdom generator functor
         * @param voronoiCell voronoi cell
         */
        DINLINE bool isNeededSubdivision(
             RandomGen & randomGen,
             VoronoiCell const & voronoiCell
        ) const
        {
            if ( voronoiCell.numMacroParticles > minMacroParticlesToDivide )
                return true;

            float_X halfDivisionCoefficient = ( voronoiCell.expectedNumMacroParticles + voronoiCell.numMacroParticles ) / 2.0_X;
             1.0_X + ( voronoiCell.expectedNumMacroParticles + 1 ) / 4.0_X;

            float_X subdivisionProbability = ( voronoiCell.expectedNumMacroParticles - 1.0_X ) / ( halfDivisionCoefficient - 1.0_X );

            // spectial cases for small voronoi cells
            if ( voronoiCell.numMacroParticles == 2 )
                subdivisionProbability = voronoiCell.expectedNumMacroParticles - 1.0_X;

            if ( voronoiCell.numMacroParticles == 3 )
                subdivisionProbability = ( voronoiCell.expectedNumMacroParticles - 1 ) / 2.0;

           return randomGen() < subdivisionProbability;
        }

         /** Decide that subdivision should be done
         * information from parents voronoi cells
         *
         * @param randomGen ramdom generator functor
         * @param voronoiCell voronoi cell
         */
        DINLINE bool isSpreadEnoughForSubdivision(
            uint8_t & splittingComponent,
            VoronoiCell & voronoiCell
           ) const
           {
                bool isSpreadEnoughForSubdivision = true;
                float_X maxSpreadValue = voronoiCell.getMaxValueSpread2( splittingComponent, simDim );

                if ( voronoiCell.splittingStage == VoronoiSplittingStage::position && maxSpreadValue < this->posSpreadThreshold )
                {
                    voronoiCell.inversersSplittingStage();
                    maxSpreadValue = voronoiCell.getMaxValueSpread2( splittingComponent, simDim );
                    if ( maxSpreadValue < this->momSpreadThreshold ) {
                        voronoiCell.setToReadyForMerging();
                        isSpreadEnoughForSubdivision = false;
                    }
                }
                if ( voronoiCell.splittingStage == VoronoiSplittingStage::momentum && maxSpreadValue < this->momSpreadThreshold )
                {
                    voronoiCell.inversersSplittingStage();
                    maxSpreadValue = voronoiCell.getMaxValueSpread2( splittingComponent, simDim );
                    if ( maxSpreadValue < this->posSpreadThreshold ) {
                        voronoiCell.setToReadyForMerging();
                        isSpreadEnoughForSubdivision = false;
                    }
                }
            return isSpreadEnoughForSubdivision;
        }

        /** Merge all particles in voronoi cell into one
         * new momentum is weighted average of all particles momentums
         * new position is weighted average of all particles positions
         * new weight is sum of all particles weights
         *
         * @param particle -- current particle
         * @param voronoiCell -- current voronoi cell
         */
        template< typename T_Particle,  typename T_Acc >
        DINLINE void mergeVoronoiCell(
            T_Acc const & acc,
            T_Particle & particle,
            const VoronoiCell & voronoiCell
        )
        {
            if( voronoiCell.isFirstParticle( acc ) )
            {
                /* I am the first particle in the Voronoi cell
                 * => get dressed with Voronoi cell's attributes */

                pmacc::DataSpace< simDim > particleCellIdx = ::pmacc::math::Vector<int, simDim>::create( 0 );

                floatD_X relativePosition = ::pmacc::math::Vector< float_X, simDim >::create( 0.0_X );
                this->getSuperCellPos( voronoiCell.meanPositionValue, particleCellIdx, relativePosition );

                lcellId_t localCellIdx =
                    pmacc::math::linearize( pmacc::math::CT::shrinkTo< SuperCellSize, simDim - 1 >::type::toRT(), particleCellIdx );

                particle[localCellIdx_] = localCellIdx;

                particle[position_] = relativePosition;

                particle[momentum_] = voronoiCell.meanMomentumValue * voronoiCell.numRealParticles;;
                particle[weighting_] = voronoiCell.numRealParticles;
            }
            else
            {
                /* I am not the first particle in the Voronoi cell
                 * => remove me */
                particle[multiMask_] = 0;
            }
        }


        /** This method handles the merging process on the single-particle level.
         *
         * It is called in the main loop of the merging algorithm.
         * Depending on the state of the Voronoi cell where the particle belongs
         * to the execution is forked into distinct sub-processes.
         *
         * @param cellIdx n-dim. cell index from the origin of the local domain
         * @param listVoronoiCells fixed-sized array of Voronoi cells
         */
        template< typename T_Acc >
        DINLINE void processParticles(
            T_Acc const & acc,
            const pmacc::math::Int<simDim>& cellIdx,
            ArrayVoronoiCells& listVoronoiCells
        )
        {
            //! \todo change this as soon as the kernel support lock step programming
            constexpr uint32_t numWorkers = pmacc::math::CT::volume< SuperCellSize >::type::value;
            const uint32_t workerIdx = DataSpaceOperations< simDim >::template map<
                SuperCellSize
            >( cellIdx % SuperCellSize::toRT() );
            particleAccess::Cell2Particle< SuperCellSize, numWorkers > forEachFrame;
            forEachFrame(
                acc,
                this->particlesBox,
                workerIdx,
                cellIdx,
                [&]( const T_Acc & acc, FramePtr frame, const int linearThreadIdx )
                {
                    auto particle = frame[linearThreadIdx];
                    const voronoiCellId::type voronoiCellId = particle[voronoiCellId_];

                     if( voronoiCellId == -1 )
                        return;

                    VoronoiCell& voronoiCell = listVoronoiCells[voronoiCellId];

                    const floatD_X position = this->getParticlePosWithinSuperCell(
                        particle[localCellIdx_],
                        particle[position_]
                    );

                    const float_X weighting = particle[weighting_];
                    const float3_X momentum = particle[momentum_] / weighting;

                    switch( voronoiCell.status )
                    {
                    case VoronoiStatus::collecting:
                        voronoiCell.addParticle(
                            acc,
                            position,
                            momentum,
                            weighting
                        );

                        break;

                    case VoronoiStatus::splitting:
                        {
                            /* determine in what sub-Voronoi cell the particle falls */
                            const voronoiCellId::type subVoronoiCellId = voronoiCell.getSubVoronoiCell(
                                position,
                                momentum
                            );

                            particle[voronoiCellId_] = subVoronoiCellId;

                            /* place particle into one of the two sub-Voronoi cells */
                            listVoronoiCells[subVoronoiCellId].addParticle(
                                acc,
                                position,
                                momentum,
                                weighting
                            );
                        }

                        break;

                    case VoronoiStatus::abort:
                        /* check out of the Voronoi cell */
                        particle[voronoiCellId_] = -1;

                        break;

                    case VoronoiStatus::readyForMerging:
                        /* merge all particles of this Voronoi cell */
                        mergeVoronoiCell( acc, particle, voronoiCell );

                        /* check out of the Voronoi cell */
                        particle[voronoiCellId_] = -1;
                    }
                },
                particles::filter::All{}
            );
        }

        /** This method handles the merging process on the Voronoi cell level.
         *
         * It is called in the main loop of the merging algorithm.
         * It does the transition of the distinct states of each Voronoi cell.
         *
         * @param listVoronoiCells fixed-sized array of Voronoi cells
         * @param voronoiIndexPool holds indices of active Voronoi cells within `listVoronoiCells`
         */
        DINLINE void processVoronoiCells(
            ArrayVoronoiCells& listVoronoiCells,
            VoronoiIndexPool& voronoiIndexPool,
            RandomGen& randomGen
        ) const
        {
            for( voronoiCellId::type voronoiCellId : voronoiIndexPool )
            {
             VoronoiCell& voronoiCell = listVoronoiCells[voronoiCellId];
                switch( voronoiCell.status )
                {
                case VoronoiStatus::collecting:
                    {
                        if ( voronoiCell.numMacroParticles < 2 )
                            {
                                voronoiCell.setToAbort();
                                break;
                            }
                        /* finalize cell parameters calculation */
                        voronoiCell.finalizePrecalculationValues( minMacroParticlesToDivide, ratioLeftParticles );

                        /* check that statistically subdivision is needed */
                        if ( isNeededSubdivision( randomGen, voronoiCell ) )
                        {
                            uint8_t splittingComponent;
                            float_X maxSpreadValue = voronoiCell.getMaxValueSpread2( splittingComponent, simDim );

                            /* check if Voronoi cell is large enought in spread of position or momentum */
                            if ( !isSpreadEnoughForSubdivision( splittingComponent, voronoiCell ) )
                                break;

                            /* create two new sub Voronoi cells */
                            voronoiCell.setToSplitting(
                                splittingComponent,
                                voronoiIndexPool.get(), /* lower Voronoi cell id */
                                voronoiIndexPool.get()  /* higher Voronoi cell id */
                            );

                            /* abort if Voronoi index pool is full */
                            if( voronoiCell.lowerCellId == -1 || voronoiCell.higherCellId == -1 )
                            {
                                voronoiCell.setToAbort();
                                break;
                            }

                            /* for better subdivision in each step we change splitting state */
                              VoronoiSplittingStage currentVoronoiStage;
                              if( voronoiCell.splittingStage == VoronoiSplittingStage::position )
                                currentVoronoiStage = VoronoiSplittingStage::momentum;
                            else
                                currentVoronoiStage = VoronoiSplittingStage::position;

                            /* initialize the two new sub Voronoi cells in `collecting` state */
                            listVoronoiCells[voronoiCell.lowerCellId] = VoronoiCell(
                                currentVoronoiStage,
                                voronoiCell.numMacroParticles,
                                voronoiCell.expectedNumMacroParticles
                            );
                            listVoronoiCells[voronoiCell.higherCellId] = VoronoiCell(
                                currentVoronoiStage,
                                voronoiCell.numMacroParticles,
                                voronoiCell.expectedNumMacroParticles
                             );

                            break;
                        }

                        /* if the statistically subdivision is not needed
                         * or  Voronoi cell is small in spread of position or momentum
                         *
                         */
                        voronoiCell.setToReadyForMerging();

                        break;
                    }

                default:
                    /* delete Voronoi cell */
                    voronoiIndexPool.release( voronoiCellId );

                    break;
                }
            }
        }


        /** Entry point of the particle merging algorithm
         *
         * @param cellIndex n-dim. cell index from the origin of the local domain
         */
        template< typename T_Acc>
        DINLINE void operator()(
            T_Acc const & acc,
            const pmacc::math::Int<simDim>& cellIndex
        )
        {
            /* multi-dim vector from origin of the super cell to a cell in units of cells */
            const pmacc::math::Int<simDim> threadIndex = cellIndex % SuperCellSize::toRT();

            /* conversion from a multi-dim cell coordinate to a linear coordinate
             * of the cell in its super cell */
            const int linearThreadIdx = pmacc::math::linearize(
                pmacc::math::CT::shrinkTo<SuperCellSize, simDim-1>::type::toRT(),
                threadIndex
            );


            /* fixed-sized array of Voronoi cells */
            PMACC_SMEM( acc, listVoronoiCells, ArrayVoronoiCells );
            /* holds indices of active Voronoi cells within `listVoronoiCells` */
            PMACC_SMEM( acc, voronoiIndexPool, VoronoiIndexPool );

            /* number of initial Voronoi cells
             *
             * `1u << simDim` is equivalent to `pow(2, simDim)` but can be
             * calculated at compile-time to save a shared variable.
             */
            constexpr uint16_t numInitialVoronoiCells = pmacc::math::CT::volume<
                SuperCellSize
            >::type::value / ( 1u << simDim );


            pmacc::math::Int<simDim> localOffset = cellIndex / SuperCellSize::toRT() - guardSuperCells;
            constexpr uint32_t numWorkers = pmacc::math::CT::volume< SuperCellSize >::type::value;
            pmacc::mappings::threads::WorkerCfg<numWorkers> workerCfg( linearThreadIdx );

            auto generator = rngFactory( acc, localOffset, workerCfg );

            if( linearThreadIdx == 0 )
            {
                /* init index pool of Voronoi Cells */
                voronoiIndexPool = VoronoiIndexPool( numInitialVoronoiCells );
            }

            __syncthreads();

            /* set initial Voronoi cells into `collecting` state */
            if( linearThreadIdx < numInitialVoronoiCells )
                listVoronoiCells[linearThreadIdx] = VoronoiCell();
             __syncthreads();
            /* init the voronoiCellId attribute for each particle */
            this->initVoronoiCellIdAttribute( acc, cellIndex );
             __syncthreads();

            /* main loop of the merging algorithm */

            while( voronoiIndexPool.size() > 0 )
            {

                this->processParticles(
                    acc,
                    cellIndex,
                    listVoronoiCells
                );

                __syncthreads();

                /* TODO: parallelize */
                if( linearThreadIdx == 0 )
                {

                    this->processVoronoiCells(
                        listVoronoiCells,
                        voronoiIndexPool,
                        generator
                    );
                }

            __syncthreads();
            }
        }
    };


} // namespace randomizedParticleMerger
} // namespace plugins
} // namespace picongpu

